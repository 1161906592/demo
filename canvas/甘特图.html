<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8">
  <meta name="author" content="018269">
  <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no,viewport-fit=cover">
  <title>甘特图</title>
  <style>
  * { margin: 0;padding: 0; }

  canvas {
    width: 100vw;
    height: 100vh;
    display: block;
  }
  </style>
  <script src="../html/vue.js"></script>
</head>
<body>
<div id="root">
  <canvas id="canvas"
          ref="canvas"
          @click="handleClick"
          @mousewheel="handleMousewheel"
          @mousedown="handleMouseDown"></canvas>
</div>
<script>
// 线
function drawLine (ctx, pointList, { color = "#000", width = 2, lineJoin = "round", isDash = false } = {}) {
  if (pointList.length < 2) {
    return;
  }
  ctx.beginPath();
  ctx.setLineDash(isDash ? [10, 6] : []);
  let start = pointList[0];
  ctx.moveTo(start[0], start[1]);
  for (let i = 1; i < pointList.length; i++) {
    let cur = pointList[i];
    ctx.lineTo(cur[0], cur[1]);
  }
  ctx.strokeStyle = color;
  ctx.lineWidth = width;
  ctx.lineJoin = lineJoin;
  ctx.stroke();
}

// 矩形
function drawRect (ctx, { x, y, w, h }, { borderColor = "#999", borderWidth = 2, color = "#eaeaea", borderTop = true, borderRight = true, borderBottom = true, borderLeft = true } = {}) {
  ctx.beginPath();
  ctx.setLineDash([]);
  ctx.strokeStyle = borderColor;
  ctx.lineWidth = borderWidth;
  if (borderTop && borderRight && borderBottom && borderLeft) {
    ctx.rect(x, y, w, h);
    ctx.stroke();
  } else {
    if (borderTop) {
      ctx.moveTo(x, y);
      ctx.lineTo(x + w, y);
    }
    if (borderRight) {
      ctx.moveTo(x + w, y);
      ctx.lineTo(x + w, y + h);
    }
    if (borderBottom) {
      ctx.moveTo(x + w, y + h);
      ctx.lineTo(x, y + h);
    }
    if (borderLeft) {
      ctx.moveTo(x, y + h);
      ctx.lineTo(x, y);
    }
    ctx.stroke();
    ctx.moveTo(x, y);
    ctx.lineTo(x + w, y);
    ctx.lineTo(x + w, y + h);
    ctx.lineTo(x, y + h);
  }
  ctx.fillStyle = color;
  ctx.fill();
}

// 文字
function drawText (ctx, { text, x, y }, { color = "#333" } = {}) {
  ctx.beginPath();
  ctx.font = "14px bold PingFang-SC-Bold";
  ctx.fillStyle = color;
  ctx.textAlign = "center";
  ctx.textBaseline = "middle";
  ctx.fillText(text, x, y);
}

// 裁减矩形区域 溢出隐藏
function clipRect (ctx, { x, y, w, h }, execute) {
  ctx.save();
  ctx.rect(x, y, w, h);
  ctx.clip();
  execute();
  ctx.restore();
}
</script>
<script>

const configMixin = Vue.mixin({
  data () {
    return {
      dateRange: 180,
      lineSpacePX: 100,
      padding: {
        left: 100,
        right: 40,
        top: 100,
        bottom: 100
      },
      rectHeight: 50,
      splitTime: new Date().getTime(),
      leftSpacePercent: 0.5,
      scale: 1,
      scaleSpeed: 0.04,
      advanceSpaceTime: 1.5 * 60 * 1000
    };
  }
});

const utilMixin = Vue.mixin({
  methods: {
    getRectBoundary (item, xIndex) {
      const startTime = item.startTime;
      const endTime = item.endTime;
      return {
        x: (startTime - this.startTime) * this.ms2px + this.padding.left,
        y: xIndex * this.lineSpacePX + this.padding.top - this.rectHeight / 2,
        w: ~~((endTime - startTime) * this.ms2px),
        h: this.rectHeight
      };
    },
    eventToCanvas (e) {
      return {
        x: e.clientX,
        y: e.clientY
      };
    },
    // 事件获取方块
    getRectByEvent (e) {
      const { x, y } = this.eventToCanvas(e);
      const { padding, lineSpacePX, viewDataList } = this;
      let index = ~~((y - padding.top + lineSpacePX / 2) / lineSpacePX);
      if (index < viewDataList.length) {
        let planList = viewDataList[index].planList;
        let first = planList[0];
        if (first) {
          let rectBoundary = first.rectBoundary;
          if (y >= rectBoundary.y && y <= rectBoundary.y + rectBoundary.h) {
            for (let j = planList.length - 1; j >= 0; j--) {
              let rectBoundary = planList[j].rectBoundary;
              if (x <= rectBoundary.x + rectBoundary.w && x >= rectBoundary.x) {
                return {
                  xIndex: index,
                  yIndex: j,
                  rect: planList[j]
                };
              }
            }
          }
        }
      }
    },
    // 获取插入位置信息
    getInsertInfoByEvent (e) {
      let { x, y } = this.eventToCanvas(e);
      // const x = this.curReact.rect.rectBoundary.x;
      x -= this.curOffsetX;
      const { padding, lineSpacePX, viewDataList } = this;
      let xIndex = ~~((y - padding.top + lineSpacePX / 2) / lineSpacePX);
      // if (xIndex === this.curReact.xIndex) return;
      if (xIndex >= viewDataList.length) {
        xIndex = viewDataList.length - 1;
      }
      let planList = this.viewDataList[xIndex].planList;
      let isOverlay = false;
      let yIndex = 0;
      for (; yIndex < planList.length; yIndex++) {
        let item = planList[yIndex];
        if (x <= item.rectBoundary.x + item.rectBoundary.w) {
          isOverlay = true;
          if (x < item.rectBoundary.x) {
            yIndex--;
            isOverlay = false;
          }
          break;
        }
      }
      return { xIndex, yIndex: yIndex + 1, isOverlay };
    },
    // 顺移时间
    advanceTime (xIndex, yIndex) {
      const planList = this.dataList[xIndex].planList;
      const space = this.advanceSpaceTime;
      let leftRect = planList[yIndex];
      let rightIndex = yIndex + 1;
      while (rightIndex < planList.length) {
        const rightRect = planList[rightIndex];
        if (rightRect.startTime - leftRect.endTime < space) {
          let advance = (leftRect.endTime - rightRect.startTime) + space;
          rightRect.startTime += advance;
          rightRect.endTime += advance;
        } else {
          break;
        }
        rightRect.rectBoundary = this.getRectBoundary(rightRect, xIndex);
        rightIndex++;
        leftRect = rightRect;
      }
    }
  }
});

const renderMixin = Vue.mixin({
  data () {
    return {
      width: 0,
      height: 0
    };
  },
  computed: {
    idToPlan () {
      const map = {};
      this.dataList.forEach((item) => {
        item.planList.forEach((d) => {
          map[d.id] = d;
        });
      });
      return map;
    },
    ms2px () {
      const { width, padding, dateRange, scale } = this;
      return (width - padding.left - padding.right) / dateRange / 60 / 1000 * scale;
    },
    startTime () {
      const { width, padding, leftSpacePercent, splitTime, ms2px } = this;
      return splitTime - (width - padding.left - padding.right) * leftSpacePercent / ms2px;
    },
    viewDataList () {
      return this.dataList.map((item, index) => {
        item.planList = item.planList.map((d) => {
          d.rectBoundary = this.getRectBoundary(d, index);
          return d;
        });
        return item;
      });
    }
  },
  methods: {
    render ({ afterRender } = {}) {
      const { ctx, padding, width, height } = this;
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      this.renderLines();
      clipRect(ctx, { x: padding.left, y: 0, w: width - padding.right - padding.left, h: height }, () => {
        this.renderRects();
        this.renderConcatLines();
      });
      this.renderSplitLine();
      afterRender && afterRender();
    },
    // 时间线
    renderLines () {
      const { ctx, lineSpacePX, padding, width, viewDataList } = this;
      viewDataList.forEach((item, i) => {
        let curY = i * lineSpacePX + padding.top;
        drawLine(ctx, [[padding.left, curY], [width - padding.right, curY]]);
        drawText(ctx, { text: item.name, x: 50, y: curY });
      });
    },
    // 渲染计划方块
    renderRects () {
      const { viewDataList } = this;
      viewDataList.forEach((item) => {
        item.planList.forEach((item) => {
          this.renderRect(item);
        });
      });
    },
    renderRect (item) {
      const { ctx, splitTime, ms2px, rectHeight } = this;
      const startTime = item.startTime;
      const endTime = item.endTime;
      const rectBoundary = item.rectBoundary;
      // 时间线分割
      if (startTime <= splitTime && splitTime <= endTime) {
        let leftRectBoundary = {
          x: rectBoundary.x,
          y: rectBoundary.y,
          w: (splitTime - startTime) * ms2px,
          h: rectHeight,
        };
        drawRect(ctx, leftRectBoundary, {
          borderRight: false
        });
        drawRect(ctx, {
          x: rectBoundary.x + leftRectBoundary.w,
          y: rectBoundary.y,
          w: rectBoundary.w - (splitTime - startTime) * ms2px,
          h: rectHeight,
        }, {
          borderLeft: false,
          color: "orange"
        });
      } else if (startTime < splitTime) {
        drawRect(ctx, rectBoundary);
      } else {
        drawRect(ctx, rectBoundary, {
          color: "orange"
        });
      }
      drawText(ctx, {
        text: item.name,
        x: rectBoundary.x + rectBoundary.w / 2,
        y: rectBoundary.y + rectBoundary.h / 2,
      });
    },
    // 渲染关系线
    renderConcatLines () {
      const { ctx, splitTime, rectHeight, idToPlan, viewDataList } = this;
      viewDataList.forEach((item) => {
        item.planList.forEach((item) => {
          let concatPlan = idToPlan[item.concatId];
          if (concatPlan) {
            const endTime = item.endTime;
            const concatStartTime = concatPlan.startTime;
            if (endTime > concatStartTime) {
              return;
            }
            let startRectBoundary = item.rectBoundary;
            let endRectBoundary = concatPlan.rectBoundary;
            drawLine(ctx, [
              [startRectBoundary.x + startRectBoundary.w, startRectBoundary.y + rectHeight / 2],
              [endRectBoundary.x, endRectBoundary.y + rectHeight / 2]
            ], {
              isDash: true,
              color: endTime > splitTime || concatStartTime > splitTime ? "#f00" : "#999"
            });
          }
        });
      });
    },
    // 时间分割线
    renderSplitLine () {
      const { ctx, startTime, splitTime, padding, ms2px, height } = this;
      const curX = (splitTime - startTime) * ms2px + padding.left;
      drawLine(ctx, [[curX, 0], [curX, height]], { color: "#999", isDash: true });
    }
  }
});

const eventMixin = Vue.mixin({
  methods: {
    handleClick (e) {
      const { getRectByPoint } = this;
      // console.log(getRectByPoint({ x: e.clientX, y: e.clientY }));
    },
    handleMousewheel (e) {
      this.scale += this.scaleSpeed * (e.wheelDelta > 0 ? 1 : -1);
      this.scale <= 0 && (this.scale = 0.01);
      this.render();
    },
    handleMouseDown (e) {
      const { getRectByEvent } = this;
      const rect = getRectByEvent(e);
      if (rect) {
        this.curReact = rect;
        this.curOffsetX = e.clientX - rect.rect.rectBoundary.x;
        this.curOffsetY = e.clientY - rect.rect.rectBoundary.y;
        document.addEventListener("mousemove", this.handleMousemove);
        document.addEventListener("mouseup", this.handleMouseup);
      }
    },
    handleMousemove (e) {
      this.render({
        afterRender: () => {
          const rectBoundary = {
            ...this.curReact.rect.rectBoundary,
          };
          const position = this.eventToCanvas(e);
          rectBoundary.x = position.x - this.curOffsetX;
          rectBoundary.y = position.y - this.curOffsetY;
          const newRect = {
            ...this.curReact.rect
          };
          newRect.rectBoundary = rectBoundary;
          this.renderRect(newRect);
        }
      });
    },
    handleMouseup (e) {
      document.removeEventListener("mousemove", this.handleMousemove);
      document.removeEventListener("mouseup", this.handleMouseup);
      const insertInfo = this.getInsertInfoByEvent(e);
      const { xIndex, yIndex, isOverlay } = insertInfo;
      const { curOffsetX, padding, startTime, ms2px, curReact } = this;

      const rect = curReact.rect;
      const position = this.eventToCanvas(e);
      rect.startTime = (position.x - curOffsetX - padding.left) / ms2px + startTime;
      rect.endTime = rect.startTime + rect.rectBoundary.w / ms2px;
      rect.rectBoundary = this.getRectBoundary(rect, xIndex);
      this.dataList[curReact.xIndex].planList.splice(curReact.yIndex, 1);
      let insertYIndex = yIndex;
      let advanceYIndex = yIndex;
      // 本行内移动
      if (xIndex === curReact.xIndex && yIndex > curReact.yIndex) {
        insertYIndex--;
        advanceYIndex--;
      }
      if (isOverlay && advanceYIndex > 0) {
        advanceYIndex--;
      }
      this.dataList[xIndex].planList.splice(insertYIndex, 0, rect);
      this.advanceTime(xIndex, advanceYIndex);
      this.render();
    }
  }
});

new Vue({
  el: "#root",
  mixins: [configMixin, utilMixin, renderMixin, eventMixin],
  data: {
    dataList: []
  },
  mounted () {
    this.dataList = Object.freeze((function () {
      let idMap = {};

      function getConcatId () {
        let id = ~~(Math.random() * 400);
        if (idMap[id]) {
          return getConcatId();
        } else {
          idMap[id] = true;
          return id;
        }
      }

      let id = 1;
      return Array.from({ length: 8 }).map((_, index) => {
        let start = new Date().getTime() - ~~(Math.random() * 75 * 60 * 1000);
        return {
          name: (index + 1) + "#高炉",
          planList: Array.from({ length: 16 }).map((_, i) => {
            let startTemp = start;
            let end = startTemp + ~~(6 * 60 * 1000 * (Math.random() + 0.5));
            start = end + ~~(2 * 60 * 1000 * (Math.random() + 0.25));
            let concatId = getConcatId();
            return {
              id: id++,
              name: "铁次A" + (i + 1),
              startTime: startTemp,
              endTime: end,
              concatId: concatId
            };
          })
        };
      });
    })());

    const canvas = this.$refs.canvas;
    this.width = canvas.width = canvas.offsetWidth;
    this.height = canvas.height = canvas.offsetHeight;

    this.ctx = canvas.getContext("2d");
    this.render();
  }
});
</script>
</body>
</html>
